Цепочка разбораGetCurrentLexem: 'program'
PROG -> programGetCurrentLexem: 'n'
PROG -> DESC -> I1-> ID -> n GetCurrentLexem: ','
PROG -> -> ,GetCurrentLexem: 'fact'
PROG -> -> ID -> fact GetCurrentLexem: ','
PROG -> -> ,GetCurrentLexem: 'i'
PROG -> -> ID -> i GetCurrentLexem: ':'
PROG -> DESC -> TYPETYPE -> :GetCurrentLexem: '%'
TYPE -> % DESC: Saving type '%' for variablesGetCurrentLexem: ';'
DESC: Successfully declared ID 2 with type %DESC: Successfully declared ID 1 with type %DESC: Successfully declared ID 0 with type %PROG -> DESC -> ;GetCurrentLexem: 'begin'
PROG -> beginGetCurrentLexem: 'n'
StartProgram: Обрабатываем оператор, текущая лексема = 'n'=== LET START: n ===LET: Saving ID 'n' with index 0PROG -> OPER -> LET LET -> ID -> n LET: ID 'n' type = %, stack cleared and type pushedGetCurrentLexem: 'ass'
PROG -> OPER -> LET LET -> ass, currentLexValue = 'ass'GetCurrentLexem: '5'
LET: Before VIR, currentLexValue = '5'CheckNum: '5'CheckNum: decimal -> integer (%)CheckNum: '5'CheckNum: decimal -> integer (%)PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ MNOJ -> NUM -> 5 GetCurrentLexem: ';'
VIR: Expression type = %LET: Stack before LetEquale = [%, %]LetEquale: t1=%, t2=%, equal=TrueLET: After VIR, currentLexValue = ';'LET: Valid separator ';' after expressionGetCurrentLexem: 'fact'
=== LET SUCCESS ===StartProgram: Next operator 'fact' without ';' - continuingStartProgram: Обрабатываем оператор, текущая лексема = 'fact'=== LET START: fact ===LET: Saving ID 'fact' with index 1PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET LET -> ID -> fact LET: ID 'fact' type = %, stack cleared and type pushedGetCurrentLexem: 'ass'
PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET LET -> ass, currentLexValue = 'ass'GetCurrentLexem: '1'
LET: Before VIR, currentLexValue = '1'CheckNum: '1'CheckNum: decimal -> integer (%)CheckNum: '1'CheckNum: decimal -> integer (%)PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ MNOJ -> NUM -> 1 GetCurrentLexem: ';'
VIR: Expression type = %LET: Stack before LetEquale = [%, %]LetEquale: t1=%, t2=%, equal=TrueLET: After VIR, currentLexValue = ';'LET: Valid separator ';' after expressionGetCurrentLexem: 'i'
=== LET SUCCESS ===StartProgram: Next operator 'i' without ';' - continuingStartProgram: Обрабатываем оператор, текущая лексема = 'i'=== LET START: i ===LET: Saving ID 'i' with index 2PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET LET -> ID -> i LET: ID 'i' type = %, stack cleared and type pushedGetCurrentLexem: 'ass'
PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET LET -> ass, currentLexValue = 'ass'GetCurrentLexem: '1'
LET: Before VIR, currentLexValue = '1'CheckNum: '1'CheckNum: decimal -> integer (%)CheckNum: '1'CheckNum: decimal -> integer (%)PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ MNOJ -> NUM -> 1 GetCurrentLexem: ';'
VIR: Expression type = %LET: Stack before LetEquale = [%, %]LetEquale: t1=%, t2=%, equal=TrueLET: After VIR, currentLexValue = ';'LET: Valid separator ';' after expressionGetCurrentLexem: 'while'
=== LET SUCCESS ===StartProgram: Next operator 'while' without ';' - continuingStartProgram: Обрабатываем оператор, текущая лексема = 'while'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> IFLO IFLO -> while GetCurrentLexem: 'i'
PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> IFLO OPRD -> SLAG SLAG -> MNOJ MNOJ -> ID -> i MNOJ: ID 'i' type = % pushed to stackGetCurrentLexem: 'LE'
PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> IFLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD VIR1 -> LE VIR1: Operation 'LE' pushed to stackGetCurrentLexem: 'n'
VIR1: Stack before VIR = [LE, %]PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> IFLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPRD -> SLAG SLAG -> MNOJ MNOJ -> ID -> n MNOJ: ID 'n' type = % pushed to stackGetCurrentLexem: 'do'
VIR: Expression type = %VIR1: Stack before CheckOperation = [%, LE, %]CheckOperation: t1=%, op=LE, t2=%, result=$VIR: Expression type = $BoolEquale: t1=$, result=TruePROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> IFLO IFLO -> doIFLO: Before OPER call, currentLexValue = 'do'GetCurrentLexem: 'fact'
IFLO: After 'do', currentLexValue = 'fact'=== LET START: fact ===LET: Saving ID 'fact' with index 1PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> IFLO OPER -> LET LET -> ID -> fact LET: ID 'fact' type = %, stack cleared and type pushedGetCurrentLexem: 'ass'
PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> IFLO OPER -> LET LET -> ass, currentLexValue = 'ass'GetCurrentLexem: 'fact'
LET: Before VIR, currentLexValue = 'fact'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> IFLO OPER -> LET OPRD -> SLAG SLAG -> MNOJ MNOJ -> ID -> fact MNOJ: ID 'fact' type = % pushed to stackGetCurrentLexem: 'mult'
PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> IFLO OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> mult GetCurrentLexem: 'i'
PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> IFLO OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ MNOJ -> ID -> i MNOJ: ID 'i' type = % pushed to stackGetCurrentLexem: ';'
CheckOperation: t1=%, op=mult, t2=%, result=%VIR: Expression type = %LET: Stack before LetEquale = [%, %]LetEquale: t1=%, t2=%, equal=TrueLET: After VIR, currentLexValue = ';'LET: Valid separator ';' after expressionGetCurrentLexem: 'i'
=== LET SUCCESS ===StartProgram: Next operator 'i' without ';' - continuingStartProgram: Обрабатываем оператор, текущая лексема = 'i'=== LET START: i ===LET: Saving ID 'i' with index 2PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> IFLO OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> LET LET -> ID -> i LET: ID 'i' type = %, stack cleared and type pushedGetCurrentLexem: 'ass'
PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> IFLO OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> LET LET -> ass, currentLexValue = 'ass'GetCurrentLexem: 'i'
LET: Before VIR, currentLexValue = 'i'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> IFLO OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ MNOJ -> ID -> i MNOJ: ID 'i' type = % pushed to stackGetCurrentLexem: 'plus'
PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> IFLO OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ OPRD -> plus GetCurrentLexem: '1'
CheckNum: '1'CheckNum: decimal -> integer (%)CheckNum: '1'CheckNum: decimal -> integer (%)PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> IFLO OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ OPRD -> SLAG SLAG -> MNOJ MNOJ -> NUM -> 1 GetCurrentLexem: ';'
CheckOperation: t1=%, op=plus, t2=%, result=%VIR: Expression type = %LET: Stack before LetEquale = [%, %]LetEquale: t1=%, t2=%, equal=TrueLET: After VIR, currentLexValue = ';'LET: Valid separator ';' after expressionGetCurrentLexem: 'write'
=== LET SUCCESS ===StartProgram: Next operator 'write' without ';' - continuingStartProgram: Обрабатываем оператор, текущая лексема = 'write'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> IFLO OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OUPU -> write GetCurrentLexem: '('
PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> IFLO OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OUPU -> ( GetCurrentLexem: 'fact'
PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> IFLO OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OPRD -> SLAG SLAG -> MNOJ MNOJ -> ID -> fact MNOJ: ID 'fact' type = % pushed to stackGetCurrentLexem: ')'
VIR: Expression type = %PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> IFLO OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OUPU -> ) GetCurrentLexem: 'end'
PROG -> endGetCurrentLexem: '.'
PROG -> .
