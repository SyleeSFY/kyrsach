Цепочка разбораGetCurrentLexem: 'program'
PROG -> programGetCurrentLexem: 'i'
PROG -> DESC -> I1-> ID -> i GetCurrentLexem: ','
PROG -> -> ,GetCurrentLexem: 'j'
PROG -> -> ID -> j GetCurrentLexem: ','
PROG -> -> ,GetCurrentLexem: 'product'
PROG -> -> ID -> product GetCurrentLexem: ':'
PROG -> DESC -> TYPETYPE -> :GetCurrentLexem: '%'
TYPE -> % DESC: Saving type '%' for variablesGetCurrentLexem: ';'
DESC: Successfully declared ID 2 with type %DESC: Successfully declared ID 1 with type %DESC: Successfully declared ID 0 with type %PROG -> DESC -> ;GetCurrentLexem: 'begin'
PROG -> beginGetCurrentLexem: 'product'
StartProgram: Обрабатываем оператор, текущая лексема = 'product'=== LET START: product ===LET: Saving ID 'product' with index 2PROG -> OPER -> LET LET -> ID -> product LET: Pushed ID type '%' to stackGetCurrentLexem: 'ass'
LET -> assGetCurrentLexem: '0'
OPRD START: currentLexValue = '0'SLAG START: currentLexValue = '0'MNOJ START: currentLexValue = '0'CheckNum: '0'CheckNum: decimal -> integer (%)CheckNum: '0'CheckNum: decimal -> integer (%)PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ MNOJ -> NUM -> 0 POLIZ[0]: Constant '0'GetCurrentLexem: ';'
MNOJ END (NUM): currentLexValue = ';'SLAG END: currentLexValue = ';'OPRD END: currentLexValue = ';'VIR: Expression type = %LetEquale: t1(ID)=%, t2(expression)=%, equal=TruePOLIZ[1]: Variable 'product'LET: Added ID 'product' to POLIZ after expressionPOLIZ[2]: Operation '='LET: Added assignment operationGetCurrentLexem: 'for'
LET: Skipping ';'=== LET SUCCESS ===StartProgram: Next operator 'for' without ';' - continuingStartProgram: Обрабатываем оператор, текущая лексема = 'for'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO FIXLO -> for GetCurrentLexem: 'i'
=== LET START: i ===LET: Saving ID 'i' with index 0PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO FIXLO -> LET LET -> ID -> i LET: Pushed ID type '%' to stackGetCurrentLexem: 'ass'
LET -> assGetCurrentLexem: '1'
OPRD START: currentLexValue = '1'SLAG START: currentLexValue = '1'MNOJ START: currentLexValue = '1'CheckNum: '1'CheckNum: decimal -> integer (%)CheckNum: '1'CheckNum: decimal -> integer (%)PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO FIXLO -> LET OPRD -> SLAG SLAG -> MNOJ MNOJ -> NUM -> 1 POLIZ[3]: Constant '1'GetCurrentLexem: 'to'
MNOJ END (NUM): currentLexValue = 'to'SLAG END: currentLexValue = 'to'OPRD END: currentLexValue = 'to'VIR: Expression type = %LetEquale: t1(ID)=%, t2(expression)=%, equal=TruePOLIZ[4]: Variable 'i'LET: Added ID 'i' to POLIZ after expressionPOLIZ[5]: Operation '='LET: Added assignment operation=== LET SUCCESS ===FIXLO: After first LET, currentLexValue = 'to'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO FIXLO -> to GetCurrentLexem: '3'
FIXLO: Loop start label at position 6POLIZ[6]: Variable 'i'FIXLO: Added variable i at position 6OPRD START: currentLexValue = '3'SLAG START: currentLexValue = '3'MNOJ START: currentLexValue = '3'CheckNum: '3'CheckNum: decimal -> integer (%)CheckNum: '3'CheckNum: decimal -> integer (%)PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ MNOJ -> NUM -> 3 POLIZ[7]: Constant '3'GetCurrentLexem: 'do'
MNOJ END (NUM): currentLexValue = 'do'SLAG END: currentLexValue = 'do'OPRD END: currentLexValue = 'do'VIR: Expression type = %POLIZ[8]: Operation 'LE'FIXLO: Added LE operation at position 8POLIZ[9]: Operation '!F'FIXLO: Added !F operation at position 9PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD FIXLO -> doGetCurrentLexem: 'for'
PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO FIXLO -> for GetCurrentLexem: 'j'
=== LET START: j ===LET: Saving ID 'j' with index 1PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO FIXLO -> LET LET -> ID -> j LET: Pushed ID type '%' to stackGetCurrentLexem: 'ass'
LET -> assGetCurrentLexem: '1'
OPRD START: currentLexValue = '1'SLAG START: currentLexValue = '1'MNOJ START: currentLexValue = '1'CheckNum: '1'CheckNum: decimal -> integer (%)CheckNum: '1'CheckNum: decimal -> integer (%)PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO FIXLO -> LET OPRD -> SLAG SLAG -> MNOJ MNOJ -> NUM -> 1 POLIZ[10]: Constant '1'GetCurrentLexem: 'to'
MNOJ END (NUM): currentLexValue = 'to'SLAG END: currentLexValue = 'to'OPRD END: currentLexValue = 'to'VIR: Expression type = %LetEquale: t1(ID)=%, t2(expression)=%, equal=TruePOLIZ[11]: Variable 'j'LET: Added ID 'j' to POLIZ after expressionPOLIZ[12]: Operation '='LET: Added assignment operation=== LET SUCCESS ===FIXLO: After first LET, currentLexValue = 'to'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO FIXLO -> to GetCurrentLexem: '4'
FIXLO: Loop start label at position 13POLIZ[13]: Variable 'i'FIXLO: Added variable i at position 13OPRD START: currentLexValue = '4'SLAG START: currentLexValue = '4'MNOJ START: currentLexValue = '4'CheckNum: '4'CheckNum: decimal -> integer (%)CheckNum: '4'CheckNum: decimal -> integer (%)PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ MNOJ -> NUM -> 4 POLIZ[14]: Constant '4'GetCurrentLexem: 'do'
MNOJ END (NUM): currentLexValue = 'do'SLAG END: currentLexValue = 'do'OPRD END: currentLexValue = 'do'VIR: Expression type = %POLIZ[15]: Operation 'LE'FIXLO: Added LE operation at position 15POLIZ[16]: Operation '!F'FIXLO: Added !F operation at position 16PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD FIXLO -> doGetCurrentLexem: 'product'
=== LET START: product ===LET: Saving ID 'product' with index 2PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET LET -> ID -> product LET: Pushed ID type '%' to stackGetCurrentLexem: 'ass'
LET -> assGetCurrentLexem: 'product'
OPRD START: currentLexValue = 'product'SLAG START: currentLexValue = 'product'MNOJ START: currentLexValue = 'product'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ MNOJ -> ID -> product MNOJ: ID 'product' type = % pushed to stackPOLIZ[17]: Variable 'product'GetCurrentLexem: 'plus'
MNOJ END (ID): currentLexValue = 'plus'SLAG END: currentLexValue = 'plus'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ OPRD -> plus GetCurrentLexem: 'i'
SLAG START: currentLexValue = 'i'MNOJ START: currentLexValue = 'i'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ MNOJ -> ID -> i MNOJ: ID 'i' type = % pushed to stackPOLIZ[18]: Variable 'i'GetCurrentLexem: 'mult'
MNOJ END (ID): currentLexValue = 'mult'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ SLAG -> mult GetCurrentLexem: 'j'
MNOJ START: currentLexValue = 'j'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ MNOJ -> ID -> j MNOJ: ID 'j' type = % pushed to stackPOLIZ[19]: Variable 'j'GetCurrentLexem: 'end'
MNOJ END (ID): currentLexValue = 'end'SLAG: CheckOperation: t1=%, op=mult, t2=%, result=%POLIZ[20]: Operation 'mult'SLAG: Performed mult -> %SLAG END: currentLexValue = 'end'OPRD: CheckOperation: t1=%, op=plus, t2=%, result=%POLIZ[21]: Operation 'plus'OPRD: Performed plus -> %OPRD END: currentLexValue = 'end'VIR: Expression type = %LetEquale: t1(ID)=%, t2(expression)=%, equal=TruePOLIZ[22]: Variable 'product'LET: Added ID 'product' to POLIZ after expressionPOLIZ[23]: Operation '='LET: Added assignment operation=== LET SUCCESS ===POLIZ[24]: Variable 'i'FIXLO: Added variable i for increment at position 24POLIZ[25]: Constant '1'FIXLO: Added constant 1 at position 25POLIZ[26]: Operation 'plus'FIXLO: Added plus operation at position 26POLIZ[27]: Variable 'i'FIXLO: Added variable i for assignment at position 27POLIZ[28]: Operation '='FIXLO: Added = operation at position 28POLIZ[29]: Operation '!'FIXLO: Added ! operation at position 29 to jump to L13FIXLO: Set !F at position 16 to jump to L30POLIZ[30]: Variable 'i'FIXLO: Added variable i for increment at position 30POLIZ[31]: Constant '1'FIXLO: Added constant 1 at position 31POLIZ[32]: Operation 'plus'FIXLO: Added plus operation at position 32POLIZ[33]: Variable 'i'FIXLO: Added variable i for assignment at position 33POLIZ[34]: Operation '='FIXLO: Added = operation at position 34POLIZ[35]: Operation '!'FIXLO: Added ! operation at position 35 to jump to L6FIXLO: Set !F at position 9 to jump to L36PROG -> endGetCurrentLexem: '.'
PROG -> .
