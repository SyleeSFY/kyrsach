Цепочка разбораGetCurrentLexem: 'program'
PROG -> programGetCurrentLexem: 'i'
PROG -> DESC -> I1-> ID -> i GetCurrentLexem: ','
PROG -> -> ,GetCurrentLexem: 'sum'
PROG -> -> ID -> sum GetCurrentLexem: ':'
PROG -> DESC -> TYPETYPE -> :GetCurrentLexem: '%'
TYPE -> % DESC: Saving type '%' for variablesGetCurrentLexem: ';'
DESC: Successfully declared ID 1 with type %DESC: Successfully declared ID 0 with type %PROG -> DESC -> ;GetCurrentLexem: 'begin'
PROG -> beginGetCurrentLexem: 'sum'
StartProgram: Обрабатываем оператор, текущая лексема = 'sum'=== LET START: sum ===LET: Saving ID 'sum' with index 1PROG -> OPER -> LET LET -> ID -> sum LET: Pushed ID type '%' to stackGetCurrentLexem: 'ass'
LET -> assGetCurrentLexem: '0'
OPRD START: currentLexValue = '0'SLAG START: currentLexValue = '0'MNOJ START: currentLexValue = '0'CheckNum: '0'CheckNum: decimal -> integer (%)NUM: Checking '0', result=1PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ MNOJ -> NUM -> 0 POLIZ[0]: Constant '0'GetCurrentLexem: 'for'
MNOJ END (NUM): currentLexValue = 'for'SLAG END: currentLexValue = 'for'OPRD END: currentLexValue = 'for'VIR: Expression type = %LetEquale: t1(ID)=%, t2(expression)=%, equal=TruePOLIZ[1]: Variable 'sum'LET: Added ID 'sum' to POLIZ after expressionPOLIZ[2]: Operation '='LET: Added assignment operation=== LET SUCCESS ===StartProgram: Next operator 'for' without ';' - continuingStartProgram: Обрабатываем оператор, текущая лексема = 'for'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO FIXLO -> for GetCurrentLexem: 'i'
=== LET START: i ===LET: Saving ID 'i' with index 0PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO FIXLO -> LET LET -> ID -> i LET: Pushed ID type '%' to stackGetCurrentLexem: 'ass'
LET -> assGetCurrentLexem: '1'
OPRD START: currentLexValue = '1'SLAG START: currentLexValue = '1'MNOJ START: currentLexValue = '1'CheckNum: '1'CheckNum: decimal -> integer (%)NUM: Checking '1', result=1PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO FIXLO -> LET OPRD -> SLAG SLAG -> MNOJ MNOJ -> NUM -> 1 POLIZ[3]: Constant '1'GetCurrentLexem: 'to'
MNOJ END (NUM): currentLexValue = 'to'SLAG END: currentLexValue = 'to'OPRD END: currentLexValue = 'to'VIR: Expression type = %LetEquale: t1(ID)=%, t2(expression)=%, equal=TruePOLIZ[4]: Variable 'i'LET: Added ID 'i' to POLIZ after expressionPOLIZ[5]: Operation '='LET: Added assignment operation=== LET SUCCESS ===FIXLO: After first LET, currentLexValue = 'to'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO FIXLO -> to GetCurrentLexem: '5'
Created label m1:POLIZ[6]: Label m1:FIXLO: Loop start label m1 at position 6POLIZ[7]: Variable 'i'FIXLO: Added variable i at position 7OPRD START: currentLexValue = '5'SLAG START: currentLexValue = '5'MNOJ START: currentLexValue = '5'CheckNum: '5'CheckNum: decimal -> integer (%)NUM: Checking '5', result=1PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ MNOJ -> NUM -> 5 POLIZ[8]: Constant '5'GetCurrentLexem: 'do'
MNOJ END (NUM): currentLexValue = 'do'SLAG END: currentLexValue = 'do'OPRD END: currentLexValue = 'do'VIR: Expression type = %POLIZ[9]: Operation 'LE'FIXLO: Added LE operation at position 9POLIZ[10]: УПЛ m2FIXLO: Added УПЛ operation at position 10 to jump to m2PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD FIXLO -> doGetCurrentLexem: 'sum'
=== LET START: sum ===LET: Saving ID 'sum' with index 1PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET LET -> ID -> sum LET: Pushed ID type '%' to stackGetCurrentLexem: 'ass'
LET -> assGetCurrentLexem: 'sum'
OPRD START: currentLexValue = 'sum'SLAG START: currentLexValue = 'sum'MNOJ START: currentLexValue = 'sum'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ MNOJ -> ID -> sum MNOJ: ID 'sum' type = % pushed to stackPOLIZ[11]: Variable 'sum'GetCurrentLexem: 'plus'
MNOJ END (ID): currentLexValue = 'plus'SLAG END: currentLexValue = 'plus'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ OPRD -> plus GetCurrentLexem: 'i'
SLAG START: currentLexValue = 'i'MNOJ START: currentLexValue = 'i'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ MNOJ -> ID -> i MNOJ: ID 'i' type = % pushed to stackPOLIZ[12]: Variable 'i'GetCurrentLexem: '@'
MNOJ END (ID): currentLexValue = '@'SLAG END: currentLexValue = '@'GetType: op='plus', t1='%', t2='%'OPRD: CheckOperation: t1=%, op=plus, t2=%, result=%POLIZ[13]: Operation 'plus'OPRD: Performed plus -> %OPRD END: currentLexValue = '@'VIR: Expression type = %LetEquale: t1(ID)=%, t2(expression)=%, equal=TruePOLIZ[14]: Variable 'sum'LET: Added ID 'sum' to POLIZ after expressionPOLIZ[15]: Operation '='LET: Added assignment operation=== LET SUCCESS ===FIXLO: Found @ for compound statementGetCurrentLexem: 'write'
PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OUPU -> write GetCurrentLexem: '('
PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OUPU -> ( GetCurrentLexem: 'i'
OPRD START: currentLexValue = 'i'SLAG START: currentLexValue = 'i'MNOJ START: currentLexValue = 'i'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OPRD -> SLAG SLAG -> MNOJ MNOJ -> ID -> i MNOJ: ID 'i' type = % pushed to stackPOLIZ[16]: Variable 'i'GetCurrentLexem: ')'
MNOJ END (ID): currentLexValue = ')'SLAG END: currentLexValue = ')'OPRD END: currentLexValue = ')'VIR: Expression type = %PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OUPU -> ) POLIZ[17]: Operation 'W'GetCurrentLexem: '@'
FIXLO: Found @ for compound statementGetCurrentLexem: 'write'
PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OUPU -> write GetCurrentLexem: '('
PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OUPU -> ( GetCurrentLexem: 'sum'
OPRD START: currentLexValue = 'sum'SLAG START: currentLexValue = 'sum'MNOJ START: currentLexValue = 'sum'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OPRD -> SLAG SLAG -> MNOJ MNOJ -> ID -> sum MNOJ: ID 'sum' type = % pushed to stackPOLIZ[18]: Variable 'sum'GetCurrentLexem: ')'
MNOJ END (ID): currentLexValue = ')'SLAG END: currentLexValue = ')'OPRD END: currentLexValue = ')'VIR: Expression type = %PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OUPU -> ) POLIZ[19]: Operation 'W'GetCurrentLexem: 'write'
POLIZ[20]: Variable 'i'FIXLO: Added variable i for increment at position 20POLIZ[21]: Constant '1'FIXLO: Added constant 1 at position 21POLIZ[22]: Operation 'plus'FIXLO: Added plus operation at position 22POLIZ[23]: Variable 'i'FIXLO: Added variable i for assignment at position 23POLIZ[24]: Operation '='FIXLO: Added = operation at position 24POLIZ[25]: БП m1FIXLO: Added БП operation at position 25 to jump to m1Created label m2: with value 2POLIZ[26]: Label m2:FIXLO: Added exit label m2StartProgram: Next operator 'write' without ';' - continuingStartProgram: Обрабатываем оператор, текущая лексема = 'write'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OUPU -> write GetCurrentLexem: '('
PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OUPU -> ( GetCurrentLexem: 'sum'
OPRD START: currentLexValue = 'sum'SLAG START: currentLexValue = 'sum'MNOJ START: currentLexValue = 'sum'PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OPRD -> SLAG SLAG -> MNOJ MNOJ -> ID -> sum MNOJ: ID 'sum' type = % pushed to stackPOLIZ[27]: Variable 'sum'GetCurrentLexem: ')'
MNOJ END (ID): currentLexValue = ')'SLAG END: currentLexValue = ')'OPRD END: currentLexValue = ')'VIR: Expression type = %PROG -> OPER -> LET OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> FIXLO OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> LET OPRD -> SLAG SLAG -> MNOJ SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OPER -> OUPU OPRD -> SLAG SLAG -> MNOJ VIR -> OPRD OUPU -> ) POLIZ[28]: Operation 'W'GetCurrentLexem: 'end'
PROG -> endGetCurrentLexem: '.'
PROG -> .
